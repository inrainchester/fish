<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>大鱼吃小鱼（手机触摸版）</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #8fd3ff;
      overflow: hidden; /* 防止页面滚动 */
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      touch-action: none; /* 关键：阻止浏览器把触摸当成滚动/缩放 */
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 10px;
      font: 14px/1.2 system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      color: rgba(0,0,0,0.75);
      background: rgba(255,255,255,0.6);
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      user-select: none;
      -webkit-user-select: none;
      pointer-events: none;
    }
    .centerTip {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      text-align: center;
      font: 16px/1.4 system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      color: rgba(0,0,0,0.75);
      background: rgba(255,255,255,0.75);
      padding: 12px 14px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      -webkit-user-select: none;
    }
    .btn {
      display: inline-block;
      margin-top: 10px;
      padding: 10px 14px;
      border-radius: 10px;
      background: rgba(0,0,0,0.78);
      color: #fff;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud" id="hud">分数: 0<br>体型: 18</div>
  <div class="centerTip" id="tip">
    手指按住屏幕移动<br/>大鱼会游向你的手指<br/>
    <span class="btn">点一下开始</span>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const hud = document.getElementById("hud");
  const tip = document.getElementById("tip");

  let W = 0, H = 0, DPR = 1;

  function resize() {
    DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // 玩家大鱼
  const player = {
    x: W / 2,
    y: H / 2,
    r: 18,
    speed: 4.2,
    targetX: W / 2,
    targetY: H / 2,
    alive: true
  };

  // 游戏状态
  let started = false;
  let score = 0;
  let fishes = []; // 小鱼/敌鱼
  let spawnTimer = 0;

  function rand(a, b) { return a + Math.random() * (b - a); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function spawnFish() {
    // 随机从边缘生成
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if (side === 0) { x = -30; y = rand(0, H); }
    if (side === 1) { x = W + 30; y = rand(0, H); }
    if (side === 2) { x = rand(0, W); y = -30; }
    if (side === 3) { x = rand(0, W); y = H + 30; }

    // 鱼大小：有概率出“比你大一点的敌鱼”
    const danger = Math.random() < 0.22;
    const r = danger ? rand(player.r * 0.95, player.r * 1.35) : rand(8, Math.max(10, player.r * 0.85));
    const sp = danger ? rand(1.2, 2.2) : rand(0.8, 1.8);

    // 速度方向朝向场内随机点
    const tx = rand(0, W), ty = rand(0, H);
    const dx = tx - x, dy = ty - y;
    const len = Math.hypot(dx, dy) || 1;

    fishes.push({
      x, y, r,
      vx: (dx / len) * sp,
      vy: (dy / len) * sp,
      danger,
    });
  }

  function drawBackground() {
    // 简单水波背景（轻量）
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = "#8fd3ff";
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = 0.12;
    ctx.lineWidth = 2;
    ctx.beginPath();
    const t = performance.now() * 0.001;
    for (let i = 0; i < 6; i++) {
      const y = (H / 6) * i + 30 * Math.sin(t + i);
      ctx.moveTo(0, y);
      for (let x = 0; x <= W; x += 30) {
        ctx.lineTo(x, y + 10 * Math.sin(t * 1.3 + x * 0.02 + i));
      }
    }
    ctx.strokeStyle = "#0b5aa8";
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawFishCircle(x, y, r, color, eye = true) {
    // 身体
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();

    // 简单尾巴
    ctx.beginPath();
    ctx.moveTo(x - r * 0.2, y);
    ctx.lineTo(x - r * 1.15, y - r * 0.5);
    ctx.lineTo(x - r * 1.15, y + r * 0.5);
    ctx.closePath();
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fill();

    // 眼睛
    if (eye) {
      ctx.beginPath();
      ctx.arc(x + r * 0.35, y - r * 0.18, Math.max(2, r * 0.12), 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + r * 0.38, y - r * 0.18, Math.max(1.5, r * 0.06), 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fill();
    }
  }

  function updatePlayer() {
    // 平滑追随目标点
    const dx = player.targetX - player.x;
    const dy = player.targetY - player.y;
    const dist = Math.hypot(dx, dy);

    if (dist > 0.5) {
      const step = Math.min(player.speed, dist);
      player.x += (dx / dist) * step;
      player.y += (dy / dist) * step;
    }

    // 边界限制
    player.x = clamp(player.x, player.r, W - player.r);
    player.y = clamp(player.y, player.r, H - player.r);
  }

  function updateFishes() {
    for (const f of fishes) {
      f.x += f.vx;
      f.y += f.vy;
    }
    // 清除飞出屏幕太远的鱼
    fishes = fishes.filter(f => f.x > -80 && f.x < W + 80 && f.y > -80 && f.y < H + 80);
  }

  function checkEat() {
    // 逐个检测碰撞
    for (let i = fishes.length - 1; i >= 0; i--) {
      const f = fishes[i];
      const d = Math.hypot(f.x - player.x, f.y - player.y);
      if (d < f.r + player.r * 0.85) {
        if (player.r >= f.r) {
          // 吃掉
          fishes.splice(i, 1);
          score += Math.max(1, Math.floor(f.r));
          player.r += Math.max(0.35, f.r * 0.06); // 变大一点点
          // 随体型增加速度略微降低（更像大鱼笨重）
          player.speed = clamp(4.2 - (player.r - 18) * 0.015, 2.6, 4.2);
        } else {
          // 吃到比自己大的：失败
          player.alive = false;
        }
      }
    }
  }

  function draw() {
    drawBackground();

    // 小鱼
    for (const f of fishes) {
      const color = f.danger ? "#ff5a5a" : "#ffb44a";
      drawFishCircle(f.x, f.y, f.r, color);
    }

    // 玩家
    drawFishCircle(player.x, player.y, player.r, "#1e66ff");

    // HUD
    hud.innerHTML = `分数: ${score}<br>体型: ${Math.floor(player.r)}`;

    // Game Over提示
    if (!player.alive) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 28px system-ui, -apple-system, PingFang SC, Microsoft YaHei, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Game Over", W / 2, H / 2 - 10);
      ctx.font = "16px system-ui, -apple-system, PingFang SC, Microsoft YaHei, sans-serif";
      ctx.fillText("点一下重新开始", W / 2, H / 2 + 24);
    }
  }

  function loop() {
    if (!started) {
      drawBackground();
      drawFishCircle(player.x, player.y, player.r, "#1e66ff");
      requestAnimationFrame(loop);
      return;
    }

    if (player.alive) {
      updatePlayer();
      updateFishes();
      checkEat();

      // 生成小鱼：体型越大，生成稍快一点
      spawnTimer += 1;
      const interval = Math.max(18, 42 - Math.floor(player.r * 0.3));
      if (spawnTimer >= interval) {
        spawnTimer = 0;
        spawnFish();
        if (Math.random() < 0.18) spawnFish();
      }
    }

    draw();
    requestAnimationFrame(loop);
  }
  loop();

  // 触摸/鼠标控制：pointer events（手机/电脑都好用）
  function setTargetFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    player.targetX = clamp(x, player.r, W - player.r);
    player.targetY = clamp(y, player.r, H - player.r);
  }

  canvas.addEventListener("pointerdown", (e) => {
    // 开始游戏
    if (!started) {
      started = true;
      tip.style.display = "none";
      // 初始生成几条鱼
      fishes = [];
      for (let i = 0; i < 6; i++) spawnFish();
    }

    // 重新开始
    if (started && !player.alive) {
      score = 0;
      player.r = 18;
      player.speed = 4.2;
      player.alive = true;
      player.x = W / 2;
      player.y = H / 2;
      player.targetX = player.x;
      player.targetY = player.y;
      fishes = [];
      for (let i = 0; i < 6; i++) spawnFish();
    }

    canvas.setPointerCapture?.(e.pointerId);
    setTargetFromEvent(e);
  }, { passive: false });

  canvas.addEventListener("pointermove", (e) => {
    if (!started) return;
    if (!player.alive) return;
    setTargetFromEvent(e);
  }, { passive: false });

  // 禁止双击缩放（部分浏览器）
  let lastTap = 0;
  canvas.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTap < 300) e.preventDefault();
    lastTap = now;
  }, { passive: false });

})();
</script>
</body>
</html>

